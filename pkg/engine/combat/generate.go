//go:build ignore

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"text/template"
)

//nolint:tagliatelle // need to match datamine
type ValueInfo struct {
	Value float64 `json:"Value"`
}

//nolint:tagliatelle // need to match datamine
type BreakLevel struct {
	Level           int       `json:"Level"`
	BreakBaseDamage ValueInfo `json:"BreakBaseDamage"`
}

func OpenConfig(result interface{}, path ...string) error {
	jsonFile := filepath.Join(path...)
	file, err := os.Open(jsonFile)
	if err != nil {
		return err
	}
	defer file.Close()

	data, err := io.ReadAll(file)
	if err != nil {
		return err
	}

	err = json.Unmarshal(data, &result)
	if err != nil {
		return err
	}
	return nil
}

func main() {
	dmPath := os.Getenv("DM_PATH")
	if dmPath == "" {
		fmt.Println("Please provide the path to StarRailData (environment variable DM_PATH).")
		return
	}

	var breakLevels map[string]BreakLevel

	if err := OpenConfig(&breakLevels, dmPath, "ExcelOutput", "AvatarBreakDamage.json"); err != nil {
		fmt.Println(err)
		return
	}

	results := dataTmpl{
		Data: make([]float64, len(breakLevels)+1),
	}

	for _, lvl := range breakLevels {
		results.Data[lvl.Level] = lvl.BreakBaseDamage.Value
	}

	breakFile, err := os.Create("break.gen.go")
	if err != nil {
		log.Fatal(err)
	}
	defer breakFile.Close()

	tmpl, err := template.New("outbreak").Parse(tmplBreak)
	if err != nil {
		log.Fatal(err)
	}
	if err := tmpl.Execute(breakFile, results); err != nil {
		log.Fatal(err)
	}
}

type dataTmpl struct {
	Data []float64
}

var tmplBreak = `// Code generated by "combat"; DO NOT EDIT.

package combat

var BreakBaseDamage = []float64{
	{{- range $e := $.Data}}
	{{$e}},
	{{- end}}
}`
