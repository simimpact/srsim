// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.4
//   protoc               v5.28.1
// source: pb/model/enemy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../../google/protobuf/struct";
import {
  BehaviorFlag,
  behaviorFlagFromJSON,
  behaviorFlagToJSON,
  DamageType,
  damageTypeFromJSON,
  damageTypeToJSON,
} from "./enum";

export enum EnemyRank {
  RANK_INVALID = 0,
  MINION = 1,
  ELITE = 2,
  LITTLE_BOSS = 3,
  BIG_BOSS = 4,
  UNRECOGNIZED = -1,
}

export function enemyRankFromJSON(object: any): EnemyRank {
  switch (object) {
    case 0:
    case "RANK_INVALID":
      return EnemyRank.RANK_INVALID;
    case 1:
    case "MINION":
      return EnemyRank.MINION;
    case 2:
    case "ELITE":
      return EnemyRank.ELITE;
    case 3:
    case "LITTLE_BOSS":
      return EnemyRank.LITTLE_BOSS;
    case 4:
    case "BIG_BOSS":
      return EnemyRank.BIG_BOSS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnemyRank.UNRECOGNIZED;
  }
}

export function enemyRankToJSON(object: EnemyRank): string {
  switch (object) {
    case EnemyRank.RANK_INVALID:
      return "RANK_INVALID";
    case EnemyRank.MINION:
      return "MINION";
    case EnemyRank.ELITE:
      return "ELITE";
    case EnemyRank.LITTLE_BOSS:
      return "LITTLE_BOSS";
    case EnemyRank.BIG_BOSS:
      return "BIG_BOSS";
    case EnemyRank.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Enemy {
  key?: string | undefined;
  level?: number | undefined;
  weaknesses?: DamageType[] | undefined;
  debuffRes?: DebuffRES[] | undefined;
  damageRes?: DamageRES[] | undefined;
  rank?: EnemyRank | undefined;
  baseStats?: BaseStats | undefined;
  parameters?: { [key: string]: any } | undefined;
}

export interface DebuffRES {
  flag?: BehaviorFlag | undefined;
  amount?: number | undefined;
}

export interface DamageRES {
  type?: DamageType | undefined;
  amount?: number | undefined;
}

export interface BaseStats {
  atk?: number | undefined;
  def?: number | undefined;
  hp?: number | undefined;
  spd?: number | undefined;
  stance?: number | undefined;
  critChance?: number | undefined;
  critDmg?: number | undefined;
  effectRes?: number | undefined;
  minFatigue?: number | undefined;
}

function createBaseEnemy(): Enemy {
  return {
    key: "",
    level: 0,
    weaknesses: [],
    debuffRes: [],
    damageRes: [],
    rank: 0,
    baseStats: undefined,
    parameters: undefined,
  };
}

export const Enemy: MessageFns<Enemy> = {
  encode(message: Enemy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.weaknesses !== undefined && message.weaknesses.length !== 0) {
      writer.uint32(26).fork();
      for (const v of message.weaknesses) {
        writer.int32(v);
      }
      writer.join();
    }
    if (message.debuffRes !== undefined && message.debuffRes.length !== 0) {
      for (const v of message.debuffRes) {
        DebuffRES.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.damageRes !== undefined && message.damageRes.length !== 0) {
      for (const v of message.damageRes) {
        DamageRES.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    if (message.rank !== undefined && message.rank !== 0) {
      writer.uint32(48).int32(message.rank);
    }
    if (message.baseStats !== undefined) {
      BaseStats.encode(message.baseStats, writer.uint32(58).fork()).join();
    }
    if (message.parameters !== undefined) {
      Struct.encode(Struct.wrap(message.parameters), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Enemy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnemy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.weaknesses!.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.weaknesses!.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = DebuffRES.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.debuffRes!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const el = DamageRES.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.damageRes!.push(el);
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rank = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.baseStats = BaseStats.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.parameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Enemy {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      weaknesses: globalThis.Array.isArray(object?.weaknesses)
        ? object.weaknesses.map((e: any) => damageTypeFromJSON(e))
        : [],
      debuffRes: globalThis.Array.isArray(object?.debuffRes)
        ? object.debuffRes.map((e: any) => DebuffRES.fromJSON(e))
        : [],
      damageRes: globalThis.Array.isArray(object?.damageRes)
        ? object.damageRes.map((e: any) => DamageRES.fromJSON(e))
        : [],
      rank: isSet(object.rank) ? enemyRankFromJSON(object.rank) : 0,
      baseStats: isSet(object.baseStats) ? BaseStats.fromJSON(object.baseStats) : undefined,
      parameters: isObject(object.parameters) ? object.parameters : undefined,
    };
  },

  toJSON(message: Enemy): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.weaknesses?.length) {
      obj.weaknesses = message.weaknesses.map((e) => damageTypeToJSON(e));
    }
    if (message.debuffRes?.length) {
      obj.debuffRes = message.debuffRes.map((e) => DebuffRES.toJSON(e));
    }
    if (message.damageRes?.length) {
      obj.damageRes = message.damageRes.map((e) => DamageRES.toJSON(e));
    }
    if (message.rank !== undefined && message.rank !== 0) {
      obj.rank = enemyRankToJSON(message.rank);
    }
    if (message.baseStats !== undefined) {
      obj.baseStats = BaseStats.toJSON(message.baseStats);
    }
    if (message.parameters !== undefined) {
      obj.parameters = message.parameters;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Enemy>, I>>(base?: I): Enemy {
    return Enemy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Enemy>, I>>(object: I): Enemy {
    const message = createBaseEnemy();
    message.key = object.key ?? "";
    message.level = object.level ?? 0;
    message.weaknesses = object.weaknesses?.map((e) => e) || [];
    message.debuffRes = object.debuffRes?.map((e) => DebuffRES.fromPartial(e)) || [];
    message.damageRes = object.damageRes?.map((e) => DamageRES.fromPartial(e)) || [];
    message.rank = object.rank ?? 0;
    message.baseStats = (object.baseStats !== undefined && object.baseStats !== null)
      ? BaseStats.fromPartial(object.baseStats)
      : undefined;
    message.parameters = object.parameters ?? undefined;
    return message;
  },
};

function createBaseDebuffRES(): DebuffRES {
  return { flag: 0, amount: 0 };
}

export const DebuffRES: MessageFns<DebuffRES> = {
  encode(message: DebuffRES, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== undefined && message.flag !== 0) {
      writer.uint32(8).int32(message.flag);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(17).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebuffRES {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebuffRES();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.flag = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebuffRES {
    return {
      flag: isSet(object.flag) ? behaviorFlagFromJSON(object.flag) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: DebuffRES): unknown {
    const obj: any = {};
    if (message.flag !== undefined && message.flag !== 0) {
      obj.flag = behaviorFlagToJSON(message.flag);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebuffRES>, I>>(base?: I): DebuffRES {
    return DebuffRES.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebuffRES>, I>>(object: I): DebuffRES {
    const message = createBaseDebuffRES();
    message.flag = object.flag ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseDamageRES(): DamageRES {
  return { type: 0, amount: 0 };
}

export const DamageRES: MessageFns<DamageRES> = {
  encode(message: DamageRES, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(17).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DamageRES {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDamageRES();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DamageRES {
    return {
      type: isSet(object.type) ? damageTypeFromJSON(object.type) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: DamageRES): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = damageTypeToJSON(message.type);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DamageRES>, I>>(base?: I): DamageRES {
    return DamageRES.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DamageRES>, I>>(object: I): DamageRES {
    const message = createBaseDamageRES();
    message.type = object.type ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseBaseStats(): BaseStats {
  return { atk: 0, def: 0, hp: 0, spd: 0, stance: 0, critChance: 0, critDmg: 0, effectRes: 0, minFatigue: 0 };
}

export const BaseStats: MessageFns<BaseStats> = {
  encode(message: BaseStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.atk !== undefined && message.atk !== 0) {
      writer.uint32(9).double(message.atk);
    }
    if (message.def !== undefined && message.def !== 0) {
      writer.uint32(17).double(message.def);
    }
    if (message.hp !== undefined && message.hp !== 0) {
      writer.uint32(25).double(message.hp);
    }
    if (message.spd !== undefined && message.spd !== 0) {
      writer.uint32(33).double(message.spd);
    }
    if (message.stance !== undefined && message.stance !== 0) {
      writer.uint32(41).double(message.stance);
    }
    if (message.critChance !== undefined && message.critChance !== 0) {
      writer.uint32(49).double(message.critChance);
    }
    if (message.critDmg !== undefined && message.critDmg !== 0) {
      writer.uint32(57).double(message.critDmg);
    }
    if (message.effectRes !== undefined && message.effectRes !== 0) {
      writer.uint32(65).double(message.effectRes);
    }
    if (message.minFatigue !== undefined && message.minFatigue !== 0) {
      writer.uint32(73).double(message.minFatigue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BaseStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBaseStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.atk = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.def = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.hp = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.spd = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.stance = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.critChance = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.critDmg = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.effectRes = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.minFatigue = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BaseStats {
    return {
      atk: isSet(object.atk) ? globalThis.Number(object.atk) : 0,
      def: isSet(object.def) ? globalThis.Number(object.def) : 0,
      hp: isSet(object.hp) ? globalThis.Number(object.hp) : 0,
      spd: isSet(object.spd) ? globalThis.Number(object.spd) : 0,
      stance: isSet(object.stance) ? globalThis.Number(object.stance) : 0,
      critChance: isSet(object.critChance) ? globalThis.Number(object.critChance) : 0,
      critDmg: isSet(object.critDmg) ? globalThis.Number(object.critDmg) : 0,
      effectRes: isSet(object.effectRes) ? globalThis.Number(object.effectRes) : 0,
      minFatigue: isSet(object.minFatigue) ? globalThis.Number(object.minFatigue) : 0,
    };
  },

  toJSON(message: BaseStats): unknown {
    const obj: any = {};
    if (message.atk !== undefined && message.atk !== 0) {
      obj.atk = message.atk;
    }
    if (message.def !== undefined && message.def !== 0) {
      obj.def = message.def;
    }
    if (message.hp !== undefined && message.hp !== 0) {
      obj.hp = message.hp;
    }
    if (message.spd !== undefined && message.spd !== 0) {
      obj.spd = message.spd;
    }
    if (message.stance !== undefined && message.stance !== 0) {
      obj.stance = message.stance;
    }
    if (message.critChance !== undefined && message.critChance !== 0) {
      obj.critChance = message.critChance;
    }
    if (message.critDmg !== undefined && message.critDmg !== 0) {
      obj.critDmg = message.critDmg;
    }
    if (message.effectRes !== undefined && message.effectRes !== 0) {
      obj.effectRes = message.effectRes;
    }
    if (message.minFatigue !== undefined && message.minFatigue !== 0) {
      obj.minFatigue = message.minFatigue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BaseStats>, I>>(base?: I): BaseStats {
    return BaseStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BaseStats>, I>>(object: I): BaseStats {
    const message = createBaseBaseStats();
    message.atk = object.atk ?? 0;
    message.def = object.def ?? 0;
    message.hp = object.hp ?? 0;
    message.spd = object.spd ?? 0;
    message.stance = object.stance ?? 0;
    message.critChance = object.critChance ?? 0;
    message.critDmg = object.critDmg ?? 0;
    message.effectRes = object.effectRes ?? 0;
    message.minFatigue = object.minFatigue ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
