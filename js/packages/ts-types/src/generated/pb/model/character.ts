// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.28.1
// source: pb/model/character.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Property, propertyFromJSON, propertyToJSON } from "./enum";

export interface Character {
  key?: string | undefined;
  level?: number | undefined;
  maxLevel?: number | undefined;
  eidols?: number | undefined;
  traces?: string[] | undefined;
  abilities?: Abilities | undefined;
  lightCone?:
    | LightCone
    | undefined;
  /** TODO: oneof for alternative options */
  relics?: Relic[] | undefined;
  startEnergy?: number | undefined;
  startHp?: number | undefined;
}

export interface Abilities {
  attack?: number | undefined;
  skill?: number | undefined;
  ult?: number | undefined;
  talent?: number | undefined;
}

export interface LightCone {
  key?: string | undefined;
  level?: number | undefined;
  maxLevel?: number | undefined;
  imposition?: number | undefined;
}

export interface Relic {
  key?: string | undefined;
  mainStat?: RelicStat | undefined;
  subStats?: RelicStat[] | undefined;
}

export interface RelicStat {
  stat?: Property | undefined;
  amount?: number | undefined;
}

function createBaseCharacter(): Character {
  return {
    key: "",
    level: 0,
    maxLevel: 0,
    eidols: 0,
    traces: [],
    abilities: undefined,
    lightCone: undefined,
    relics: [],
    startEnergy: 0,
    startHp: 0,
  };
}

export const Character = {
  encode(message: Character, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.maxLevel !== undefined && message.maxLevel !== 0) {
      writer.uint32(24).uint32(message.maxLevel);
    }
    if (message.eidols !== undefined && message.eidols !== 0) {
      writer.uint32(32).uint32(message.eidols);
    }
    if (message.traces !== undefined && message.traces.length !== 0) {
      for (const v of message.traces) {
        writer.uint32(42).string(v!);
      }
    }
    if (message.abilities !== undefined) {
      Abilities.encode(message.abilities, writer.uint32(50).fork()).ldelim();
    }
    if (message.lightCone !== undefined) {
      LightCone.encode(message.lightCone, writer.uint32(58).fork()).ldelim();
    }
    if (message.relics !== undefined && message.relics.length !== 0) {
      for (const v of message.relics) {
        Relic.encode(v!, writer.uint32(66).fork()).ldelim();
      }
    }
    if (message.startEnergy !== undefined && message.startEnergy !== 0) {
      writer.uint32(73).double(message.startEnergy);
    }
    if (message.startHp !== undefined && message.startHp !== 0) {
      writer.uint32(81).double(message.startHp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Character {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxLevel = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.eidols = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.traces!.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.abilities = Abilities.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lightCone = LightCone.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.relics!.push(Relic.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.startEnergy = reader.double();
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.startHp = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Character {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      maxLevel: isSet(object.maxLevel) ? globalThis.Number(object.maxLevel) : 0,
      eidols: isSet(object.eidols) ? globalThis.Number(object.eidols) : 0,
      traces: globalThis.Array.isArray(object?.traces) ? object.traces.map((e: any) => globalThis.String(e)) : [],
      abilities: isSet(object.abilities) ? Abilities.fromJSON(object.abilities) : undefined,
      lightCone: isSet(object.lightCone) ? LightCone.fromJSON(object.lightCone) : undefined,
      relics: globalThis.Array.isArray(object?.relics) ? object.relics.map((e: any) => Relic.fromJSON(e)) : [],
      startEnergy: isSet(object.startEnergy) ? globalThis.Number(object.startEnergy) : 0,
      startHp: isSet(object.startHp) ? globalThis.Number(object.startHp) : 0,
    };
  },

  toJSON(message: Character): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.maxLevel !== undefined && message.maxLevel !== 0) {
      obj.maxLevel = Math.round(message.maxLevel);
    }
    if (message.eidols !== undefined && message.eidols !== 0) {
      obj.eidols = Math.round(message.eidols);
    }
    if (message.traces?.length) {
      obj.traces = message.traces;
    }
    if (message.abilities !== undefined) {
      obj.abilities = Abilities.toJSON(message.abilities);
    }
    if (message.lightCone !== undefined) {
      obj.lightCone = LightCone.toJSON(message.lightCone);
    }
    if (message.relics?.length) {
      obj.relics = message.relics.map((e) => Relic.toJSON(e));
    }
    if (message.startEnergy !== undefined && message.startEnergy !== 0) {
      obj.startEnergy = message.startEnergy;
    }
    if (message.startHp !== undefined && message.startHp !== 0) {
      obj.startHp = message.startHp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Character>, I>>(base?: I): Character {
    return Character.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Character>, I>>(object: I): Character {
    const message = createBaseCharacter();
    message.key = object.key ?? "";
    message.level = object.level ?? 0;
    message.maxLevel = object.maxLevel ?? 0;
    message.eidols = object.eidols ?? 0;
    message.traces = object.traces?.map((e) => e) || [];
    message.abilities = (object.abilities !== undefined && object.abilities !== null)
      ? Abilities.fromPartial(object.abilities)
      : undefined;
    message.lightCone = (object.lightCone !== undefined && object.lightCone !== null)
      ? LightCone.fromPartial(object.lightCone)
      : undefined;
    message.relics = object.relics?.map((e) => Relic.fromPartial(e)) || [];
    message.startEnergy = object.startEnergy ?? 0;
    message.startHp = object.startHp ?? 0;
    return message;
  },
};

function createBaseAbilities(): Abilities {
  return { attack: 0, skill: 0, ult: 0, talent: 0 };
}

export const Abilities = {
  encode(message: Abilities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attack !== undefined && message.attack !== 0) {
      writer.uint32(8).uint32(message.attack);
    }
    if (message.skill !== undefined && message.skill !== 0) {
      writer.uint32(16).uint32(message.skill);
    }
    if (message.ult !== undefined && message.ult !== 0) {
      writer.uint32(24).uint32(message.ult);
    }
    if (message.talent !== undefined && message.talent !== 0) {
      writer.uint32(32).uint32(message.talent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Abilities {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.attack = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.skill = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ult = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.talent = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Abilities {
    return {
      attack: isSet(object.attack) ? globalThis.Number(object.attack) : 0,
      skill: isSet(object.skill) ? globalThis.Number(object.skill) : 0,
      ult: isSet(object.ult) ? globalThis.Number(object.ult) : 0,
      talent: isSet(object.talent) ? globalThis.Number(object.talent) : 0,
    };
  },

  toJSON(message: Abilities): unknown {
    const obj: any = {};
    if (message.attack !== undefined && message.attack !== 0) {
      obj.attack = Math.round(message.attack);
    }
    if (message.skill !== undefined && message.skill !== 0) {
      obj.skill = Math.round(message.skill);
    }
    if (message.ult !== undefined && message.ult !== 0) {
      obj.ult = Math.round(message.ult);
    }
    if (message.talent !== undefined && message.talent !== 0) {
      obj.talent = Math.round(message.talent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Abilities>, I>>(base?: I): Abilities {
    return Abilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Abilities>, I>>(object: I): Abilities {
    const message = createBaseAbilities();
    message.attack = object.attack ?? 0;
    message.skill = object.skill ?? 0;
    message.ult = object.ult ?? 0;
    message.talent = object.talent ?? 0;
    return message;
  },
};

function createBaseLightCone(): LightCone {
  return { key: "", level: 0, maxLevel: 0, imposition: 0 };
}

export const LightCone = {
  encode(message: LightCone, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.level !== undefined && message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.maxLevel !== undefined && message.maxLevel !== 0) {
      writer.uint32(24).uint32(message.maxLevel);
    }
    if (message.imposition !== undefined && message.imposition !== 0) {
      writer.uint32(32).uint32(message.imposition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LightCone {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLightCone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxLevel = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.imposition = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LightCone {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      maxLevel: isSet(object.maxLevel) ? globalThis.Number(object.maxLevel) : 0,
      imposition: isSet(object.imposition) ? globalThis.Number(object.imposition) : 0,
    };
  },

  toJSON(message: LightCone): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.level !== undefined && message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.maxLevel !== undefined && message.maxLevel !== 0) {
      obj.maxLevel = Math.round(message.maxLevel);
    }
    if (message.imposition !== undefined && message.imposition !== 0) {
      obj.imposition = Math.round(message.imposition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LightCone>, I>>(base?: I): LightCone {
    return LightCone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LightCone>, I>>(object: I): LightCone {
    const message = createBaseLightCone();
    message.key = object.key ?? "";
    message.level = object.level ?? 0;
    message.maxLevel = object.maxLevel ?? 0;
    message.imposition = object.imposition ?? 0;
    return message;
  },
};

function createBaseRelic(): Relic {
  return { key: "", mainStat: undefined, subStats: [] };
}

export const Relic = {
  encode(message: Relic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.mainStat !== undefined) {
      RelicStat.encode(message.mainStat, writer.uint32(18).fork()).ldelim();
    }
    if (message.subStats !== undefined && message.subStats.length !== 0) {
      for (const v of message.subStats) {
        RelicStat.encode(v!, writer.uint32(26).fork()).ldelim();
      }
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Relic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mainStat = RelicStat.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subStats!.push(RelicStat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Relic {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      mainStat: isSet(object.mainStat) ? RelicStat.fromJSON(object.mainStat) : undefined,
      subStats: globalThis.Array.isArray(object?.subStats)
        ? object.subStats.map((e: any) => RelicStat.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Relic): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.mainStat !== undefined) {
      obj.mainStat = RelicStat.toJSON(message.mainStat);
    }
    if (message.subStats?.length) {
      obj.subStats = message.subStats.map((e) => RelicStat.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Relic>, I>>(base?: I): Relic {
    return Relic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Relic>, I>>(object: I): Relic {
    const message = createBaseRelic();
    message.key = object.key ?? "";
    message.mainStat = (object.mainStat !== undefined && object.mainStat !== null)
      ? RelicStat.fromPartial(object.mainStat)
      : undefined;
    message.subStats = object.subStats?.map((e) => RelicStat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRelicStat(): RelicStat {
  return { stat: 0, amount: 0 };
}

export const RelicStat = {
  encode(message: RelicStat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stat !== undefined && message.stat !== 0) {
      writer.uint32(8).int32(message.stat);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(17).double(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RelicStat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelicStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.stat = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.amount = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelicStat {
    return {
      stat: isSet(object.stat) ? propertyFromJSON(object.stat) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: RelicStat): unknown {
    const obj: any = {};
    if (message.stat !== undefined && message.stat !== 0) {
      obj.stat = propertyToJSON(message.stat);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RelicStat>, I>>(base?: I): RelicStat {
    return RelicStat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RelicStat>, I>>(object: I): RelicStat {
    const message = createBaseRelicStat();
    message.stat = object.stat ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
