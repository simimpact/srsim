// Code generated by tygo. DO NOT EDIT.
/* eslint-disable @typescript-eslint/consistent-type-definitions */
/* eslint-disable @typescript-eslint/consistent-indexed-object-style */
/* eslint-disable prettier/prettier */

//////////
// source: attribute.go

export interface Attributes {
  level: number /* int */;
  base_stats: PropMap;
  base_debuff_res: DebuffRESMap;
  weakness: WeaknessMap;
  hp_ratio: number /* float64 */;
  energy: number /* float64 */;
  max_energy: number /* float64 */;
  stance: number /* float64 */;
  max_stance: number /* float64 */;
}
export interface ModifyHPByRatio {
  /**
   * The amount of HP ratio to modify the HP by (negative will remove HP)
   */
  Ratio: number /* float64 */;
  /**
   * What ratio type should be used (should Ratio be based on MaxHP or CurrentHP)
   */
  RatioType: string;
  /**
   * The floor for how low HP can go with this modification. IE: Floor = 1 will prevent the HP
   * from reaching 0 in this modification (can reduce up to 1 HP)
   */
  Floor: number /* float64 */;
}

//////////
// source: character.go

export interface Character {
  key: string;
  level: number /* int */;
  ascension: number /* int */;
  eidolon: number /* int */;
  traces: { [key: string]: boolean};
  ability_level: AbilityLevel;
  path: string;
  element: string;
  light_cone: LightCone;
  relics: { [key: string]: number /* int */};
}
export interface AbilityLevel {
  attack: number /* int */;
  skill: number /* int */;
  ult: number /* int */;
  talent: number /* int */;
}
export interface LightCone {
  key: string;
  level: number /* int */;
  ascension: number /* int */;
  imposition: number /* int */;
  path: string;
}

//////////
// source: combat.go

export type DamageMap = { [key: string]: number /* float64 */};
export type HealMap = { [key: string]: number /* float64 */};
export interface Attack {
  /**
   * List of targets to perform this attack against (will perform 1 hit per target)
   */
  targets: string[];
  /**
   * The source target which is performing this attack
   */
  source: string;
  /**
   * The type of attack (IE: dot, ult, insert, etc)
   */
  attack_type: string;
  /**
   * The damage type of this attack (physical, fire, ice, etc)
   */
  damage_type: string;
  /**
   * Map of damage formula -> damage percentage. This is for calculating the "Base Damage" of the
   * attack. IE: info.DamageMap{model.BY_ATK: 0.5} = 50% of ATK.
   * If HitRatio is specified, all base damage multiplier will be multiplied by the hit ratio.
   * IE: info.DamageMap{model.BY_ATK: 0.5} w/ 0.5 HitRatio means 25% of ATK.
   */
  base_damage: DamageMap;
  /**
   * How much energy will be generated for the source from this attack. This energy generation
   * will scale with ERR.
   * If HitRatio is specified, the energy gained will be multiplied by the hit ratio.
   * IE: 30.0 EnergyGain with a 0.5 HitRatio means only 15.0 energy added (before ERR bonus)
   */
  energy_gain: number /* float64 */;
  /**
   * How much stance/toughness damage this attack will deal. This stance damage will scale with
   * Stance DMG% increase.
   * If HitRatio is specified, the stance damage will be multiplied by the hit ratio.
   * IE: 30.0 StanceDamage with a 0.5 HitRatio means only 15 stance dmage will occur (before bonus)
   */
  stance_damage: number /* float64 */;
  /**
   * Hit ratio reduces the BaseDamage, EnergyGain, and StanceDamage by the given percentage. This
   * is used for attacks that perform multiple hits. It is expected that the sum of all HitRatio
   * used for all hits in an attack equal 1.0 (IE: 2 attacks w/ HitRatio of 0.45 & 0.55)
   */
  hit_ratio: number /* float64 */;
  /**
   * If true, will use the "pure damage" formula. This removes some variables from the damage
   * equation, such as crit.
   */
  as_pure_damage: boolean;
  /**
   * An additional flat damage amount that can be added to the base damage
   */
  damage_value: number /* float64 */;
  /**
   * If set to true, will execute this attack in a "snapshot" state. This means that any modifiers
   * that subscribe to hit listeners will not be executed. This is used by break damage dots.
   */
  use_snapshot: boolean;
}
export interface Hit {
  /**
   * The stats of the attacker of this hit. These stats are a snapshot of the target's state and
   * can be modified
   */
  attacker?: Stats;
  /**
   * The stats of the defender of this hit. These stats are a snapshot of the target's state and
   * can be modified
   */
  defender?: Stats;
  /**
   * The type of attack (IE: dot, ult, insert, etc)
   */
  attack_type: string;
  /**
   * The damage type of this attack (physical, fire, ice, etc)
   */
  damage_type: string;
  /**
   * Map of damage formula -> damage percentage. This is for calculating the "Base Damage" of the
   * attack. IE: info.DamageMap{model.BY_ATK: 0.5} = 50% of ATK.
   * If HitRatio is specified, all base damage multiplier will be multiplied by the hit ratio.
   * IE: info.DamageMap{model.BY_ATK: 0.5} w/ 0.5 HitRatio means 25% of ATK.
   */
  base_damage: DamageMap;
  /**
   * How much energy will be generated for the source from this attack. This energy generation
   * will scale with ERR.
   * If HitRatio is specified, the energy gained will be multiplied by the hit ratio.
   * IE: 30.0 EnergyGain with a 0.5 HitRatio means only 15.0 energy added (before ERR bonus)
   */
  energy_gain: number /* float64 */;
  /**
   * How much stance/toughness damage this attack will deal. This stance damage will scale with
   * Stance DMG% increase.
   * If HitRatio is specified, the stance damage will be multiplied by the hit ratio.
   * IE: 30.0 StanceDamage with a 0.5 HitRatio means only 15 stance dmage will occur (before bonus)
   */
  stance_damage: number /* float64 */;
  /**
   * Hit ratio reduces the BaseDamage, EnergyGain, and StanceDamage by the given percentage. This
   * is used for attacks that perform multiple hits. It is expected that the sum of all HitRatio
   * used for all hits in an attack equal 1.0 (IE: 2 attacks w/ HitRatio of 0.45 & 0.55)
   */
  hit_ratio: number /* float64 */;
  /**
   * If true, will use the "pure damage" formula. This removes some variables from the damage
   * equation, such as crit.
   */
  as_pure_damage: boolean;
  /**
   * An additional flat damage amount that can be added to the base damage
   */
  damage_value: number /* float64 */;
  /**
   * If set to true, will execute this hit in a "snapshot" state. This means that any modifiers
   * that subscribe to hit listeners will not be executed. This is used by break damage dots.
   */
  use_snapshot: boolean;
}
export interface Heal {
  /**
   * The targets that the healer is healing
   */
  targets: string[];
  /**
   * The healer that is performing the heal
   */
  source: string;
  /**
   * Map of HealFormula -> Heal Percentage. This is for calculating the "Base Heal" amount of the
   * heal. IE: info.HealMap{model.BY_HEALER_MAX_HP: 0.5} = 50% of source target's MaxHP.
   */
  base_heal: HealMap;
  /**
   * Additional flat healing that can be added to the base heal amount.
   */
  heal_value: number /* float64 */;
  /**
   * If set to true, will execute this heal in a "snapshot" state. This means that any modifiers
   * that subscribe to heal listeners will not be executed. This is used by phase1 heals.
   */
  use_snapshot: boolean;
}

//////////
// source: enemy.go

export interface Enemy {
  level: number /* int */;
  max_stance: number /* float64 */;
  weakness: WeaknessMap;
  debuff_res: DebuffRESMap;
}

//////////
// source: insertpriority_string.go


//////////
// source: map.go

export type PropMap = { [key: string]: number /* float64 */};
export type DebuffRESMap = { [key: string]: number /* float64 */};
export type WeaknessMap = { [key: string]: boolean};

//////////
// source: modifier.go

/**
 * Definition of a modifier. Is used to specify and additional stats or behavior associated with
 * the target it is attached to (managed by the modifier package)
 */
export interface Modifier {
  /**
   * What modifier this instance is (used to get metadata + listeners for the modifier)
   */
  name: string;
  /**
   * TargetID for who created this modifier instance
   */
  source: string;
  /**
   * Custom state that can be used to parameterize modifier logic (listeners can depend on state)
   * Note: State will be JSON serialized for logging purposes, so should be serialization friendly.
   */
  state: any;
  /**
   * If specified, modifier will be applied with a random chance against the resistance
   * 		add prob = 1 - chance * (1 + source ERR) * (1 - target EffectRES) * (1 - target Debuff RES)
   * If unspecified, modifier will always be added (using the defined stacking logic)
   */
  chance: number /* float64 */;
  /**
   * If specified, modifier will only be applied for the given duration number of turns
   * If unspecified, will default to the Duration in the ModifierConfig.
   * When Duration reaches 0, this modifier instance will be removed. A negative duration means
   * that this modifier will never expire
   */
  duration: number /* int */;
  /**
   * When duration is > 0, the turn a modifier is added on will not count torwards the duration.
   * If this field is set to true, this will override that behavior and count the application turn
   * against the duration (if application happens before the check).
   */
  tick_immediately: boolean;
  /**
   * If specified, modifier will have the count number of stacks. In the event that an instance of
   * this modifier already exists, specifying count may replace, add to, or keep the existing stack
   * count depending on what the modifier "stacking" logic is.
   * If unspecified, will default to the Count in ModifierConfig (which will be 1 if not defined)
   * When count reaches 0, the modifier will be removed from the target.
   */
  count: number /* float64 */;
  /**
   * If specified, will set the max count allowed on this modifier in the event that it gets
   * reapplied/stacks and this instance is used.
   * If unspecified, will default to the MaxCount in ModifierConfig (which will be 1 if not defined)
   */
  max_count: number /* float64 */;
  /**
   * When Count is unspecified, CountAddWhenStack determines how much to add to count when a new
   * stack is added. Specifying this field will overrride the default value for this defined in the
   * ModifierConfig (which defaults to 0 if undefined)
   */
  count_add_when_stack: number /* float64 */;
  /**
   * Any stats/properties that are added to the target by this modifier.
   */
  stats: PropMap;
  /**
   * Any additional debuff res that are applied to the target by this modifier.
   */
  debuff_res: DebuffRESMap;
  /**
   * Any additional weaknesses that are applied to the target by this modifier.
   */
  weakness: WeaknessMap;
}
export interface Dispel {
  /**
   * what type of modifiers should be dispelled (BUFF, DEBUFF, or OTHER)
   */
  status: string;
  /**
   * what modifiers should be dispelled given the order they were added to the target.
   */
  order: string;
  /**
   * the number of modifiers to dispel of the given status type. If unspecified or <= 0, will remove
   * all modifiers matching the given status type.
   */
  count: number /* int */;
}
/**
 * this is an intermediary state to creating the final Stats snapshot
 */
export interface ModifierState {
  props: PropMap;
  debuff_res: DebuffRESMap;
  weakness: WeaknessMap;
  flags: string[];
  counts: { [key: string]: number /* int */};
  modifiers: string[];
}

//////////
// source: queue.go

/**
 * metadata on what is being inserted into the turn queue
 */
export interface Insert {
  /**
   * The logic to run when this insert is executed during the turn
   */
  Execute: any;
  /**
   * The target this insert is associated with (used to look up their current state)
   */
  Source: string;
  /**
   * Before this insert executes, will check the Source for if it contains any of the given
   * abort flags. If an abort flag matches, this insert will not be executed.
   */
  AbortFlags: string[];
  /**
   * The priority of this insert within the turn queue
   */
  Priority: InsertPriority;
}
export type InsertPriority = number /* int */;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharReviveSelf: InsertPriority = 45;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharHealSelf: InsertPriority = 48;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharReviveOthers: InsertPriority = 55;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharHealOthers: InsertPriority = 58;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharBuffSelf: InsertPriority = 65;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharInsertAttackSelf: InsertPriority = 75;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharInsertAttackOthers: InsertPriority = 115;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyReviveSelf: InsertPriority = 145;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyHealSelf: InsertPriority = 148;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyReviveOthers: InsertPriority = 155;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyHealOthers: InsertPriority = 158;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyBuffSelf: InsertPriority = 165;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyInsertAttackSelf: InsertPriority = 175;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyInsertAttackOthers: InsertPriority = 215;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const CharInsertAction: InsertPriority = 500;
/**
 * TODO: specific insert priorities for specific casses (IE: himiko vs herta, clara vs march)
 */
export const EnemyInsertAction: InsertPriority = 1000;

//////////
// source: shield.go

export type ShieldMap = { [key: string]: number /* float64 */};
export interface Shield {
  /**
   * The shielder that is creating the shield
   */
  source: string;
  /**
   * The target that the shielder is shielding
   */
  target: string;
  /**
   * Map of ShieldFormula -> Shield Percentage. This is for calculating the "base shield" amount of
   * the shield. IE: info.ShieldMap{model.ShieldFormula_SHIELD_BY_SHIELDER_ATK: 0.5} = 50% of
   * source target's ATK.
   */
  base_shield: ShieldMap;
  /**
   * Additional flat shield hp that can be added to the base heal amount.
   */
  shield_value: number /* float64 */;
}

//////////
// source: stats.go

/**
 * A snapshot of a targets stats at a point in time
 */
export interface Stats {
}
export interface StatsEncoded {
  id: string;
  hp_ratio: number /* float64 */;
  energy: number /* float64 */;
  stance: number /* float64 */;
  props: PropMap;
  debuff_res: DebuffRESMap;
  weakness: WeaknessMap;
  flags: string[];
  status_counts: { [key: string]: number /* int */};
  modifiers: string[];
  stats?: ComputedStats;
}
export interface ComputedStats {
  hp: number /* float64 */;
  atk: number /* float64 */;
  def: number /* float64 */;
  spd: number /* float64 */;
  aggro: number /* float64 */;
  crit_chance: number /* float64 */;
  crit_dmg: number /* float64 */;
  heal_boost: number /* float64 */;
  effect_hit_rate: number /* float64 */;
  effect_res: number /* float64 */;
  energy_regen: number /* float64 */;
  break_effect: number /* float64 */;
}
